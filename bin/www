#!/usr/bin/env node

const http = require('http');
const { Server } = require('socket.io');
const debug = require('debug')('tryal:server');
const config = require('../../config');
const { pool } = require('../bin/db');
const attachSocketEvents = require('../sockets');

(async () => {
    try {
        // Create the HTTP server first (we'll attach app after io + app are ready)
        const server = http.createServer();

        // Socket.IO (tuned a bit for stability)
        const io = new Server(server, {
            cors: {
                origin: '*',
                methods: ['GET', 'POST'],
            },
            // Optional: tune heartbeats if you see idle disconnects on mobile networks
            pingInterval: 25000,
            pingTimeout: 20000,
            // Allow larger payloads if you exchange big messages
            maxHttpBufferSize: 1e6,
        });

        // Build Express app, give it access to the pool + io
        const createApp = require('../app');
        const app = createApp(pool, io);

        // Port
        const port = normalizePort(process.env.PORT || config.domains.resqzone_api.port);
        app.set('port', port);
        app.set('io', io); // optional: access io via req.app.get('io')

        // Wire the app to the server
        server.on('request', app);

        // Socket handlers
        attachSocketEvents(io);

        // Start listening
        server.listen(port, '0.0.0.0', () => {
            console.log(`🚀 Server running on http://localhost:${port}`);
            console.log(`🌍 Domain: ${config.domains.resqzone_api.domain}`);
        });

        server.on('error', onError);
        server.on('listening', onListening);

        let shuttingDown = false;

        async function shutdown(signal) {
            if (shuttingDown) return;
            shuttingDown = true;
            console.log(`\n🛑 Received ${signal}. Shutting down gracefully...`);

            try {
                // 1) stop accepting new connections
                await new Promise((resolve) => server.close(resolve));
                console.log('HTTP server closed');

                // 2) close socket.io
                await new Promise((resolve) => io.close(() => resolve()));
                console.log('Socket.IO closed');

                // 3) drain and close the pool
                await pool.end();
                console.log('MySQL pool closed');
            } catch (e) {
                console.error('Error during shutdown:', e);
            } finally {
                process.exit(0);
            }
        }

        process.on('SIGINT', () => shutdown('SIGINT'));
        process.on('SIGTERM', () => shutdown('SIGTERM'));

        // Guard against unhandled errors
        process.on('unhandledRejection', (reason) => {
            console.error('Unhandled Rejection:', reason);
        });
        process.on('uncaughtException', (err) => {
            console.error('Uncaught Exception:', err);
            // Let PM2 restart us cleanly
            process.exit(1);
        });

        function normalizePort(val) {
            const p = parseInt(val, 10);
            if (Number.isNaN(p)) return val;
            if (p >= 0) return p;
            return false;
        }

        function onError(error) {
            if (error.syscall !== 'listen') throw error;
            const bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port;
            switch (error.code) {
                case 'EACCES':
                    console.error(bind + ' requires elevated privileges');
                    process.exit(1);
                case 'EADDRINUSE':
                    console.error(bind + ' is already in use');
                    process.exit(1);
                default:
                    throw error;
            }
        }

        function onListening() {
            const addr = server.address();
            const bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
            debug('Listening on ' + bind);
        }
    } catch (err) {
        console.error('🚨 Failed to start server:', err);
        process.exit(1);
    }
})();
